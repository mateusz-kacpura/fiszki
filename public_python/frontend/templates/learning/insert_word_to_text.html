{% extends "learn.html" %}

{% block title %}Multi Learning{% endblock %}

{% block learn %}

<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='project/css/learning.css') }}">

<div class="row justify-content-center">
    <!-- Lewa kolumna z kartÄ… i wyborem sĹ‚Ăłw -->
    {% include 'learning/linkq/left_column.html' %}

    <!-- Prawa kolumna z historiÄ… tĹ‚umaczeĹ„ -->
    {% include 'learning/linkq/right_column.html' %}

    <!-- Karta do wyboru tekstu -->
    {% include 'learning/linkq/load_file_loader_card.html' %}

    <!-- Miejsce na dynamiczne powiadomienia (alerty) -->
    <div id="alert-container" style="position: fixed; top: 10px; right: 10px; z-index: 1000;"></div>

</div>

<!-- Modal remains the same -->
<div class="modal fade" id="translationModal" tabindex="-1" aria-labelledby="translationModalLabel" aria-hidden="true">
    <!-- Modal content is the same -->
</div>

{% include 'learning/modals/edit-word-modal.html' %}

{% endblock %}

{% block scripts %}
<script>
    
let actionBubble = null;
let selectedTextName = "";
let selectedWords = [];
let wordCount = "";
let alertShown = false;

const textContainer = document.getElementById('text-with-blanks');
const wordContainer = document.getElementById('image-container');

let totalPages = 1;
let allTexts = [];

// Funkcja do wyĹ›wietlania alertĂłw
function showAlert(message, type = 'success') {
    const alertContainer = document.getElementById('alert-container');
    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.innerText = message;
    alertContainer.appendChild(alert);

    // UsuniÄ™cie alertu po 3 sekundach
    setTimeout(() => {
        alert.remove();
    }, 3000);
}

function showAlertOnceInInterval(message, type) {
    if (!alertShown) {
        showAlert(message, type);
        alertShown = true;
        
        // Resetowanie flagi po 5 sekundach
        setTimeout(() => {
            alertShown = false;
        }, 5000); // 5000 milisekund = 5 sekund
    }
}

/////////////////////////////////////////////////

// #        LOGIKA WCZYTYWANIA TEKSTĂ“W        #//

/////////////////////////////////////////////////

// GĹ‚Ăłwna funkcja inicjalizujÄ…ca aplikacjÄ™
document.addEventListener('DOMContentLoaded', () => {
    decideWhichTextToLoad();
});

// Pobranie tekstĂłw z serwera z uwzglÄ™dnieniem limitu i wyszukiwania
function decideWhichTextToLoad() {
    const limit = document.getElementById('textLimit').value || 10;
    const searchQuery = document.getElementById('searchInput').value || '';
    const tagQuery = document.getElementById('tagInput').value || '';

    fetch(`/user/get_texts_for_insert_words_to_text?limit=${limit}&page=${currentPage}&search=${searchQuery}&tag=${tagQuery}`)
        .then(response => response.json())
        .then(data => {
            allTexts = data.text_names;
            totalPages = data.total_pages; // ZaĹ‚ĂłĹĽmy, ĹĽe serwer zwraca teĹĽ liczbÄ™ stron
            populateTextList(allTexts);
            updatePaginationControls(); // Funkcja aktualizujÄ…ca przyciski paginacji
            showAlert('Lista tekstĂłw zostaĹ‚a zaĹ‚adowana!', 'success');
        })
        .catch(error => {
            console.error('BĹ‚Ä…d przy pobieraniu listy tekstĂłw:', error);
            showAlert('BĹ‚Ä…d przy pobieraniu listy tekstĂłw.', 'danger');
        });
}

// Funkcja generujÄ…ca listÄ™ tekstĂłw
function populateTextList(textNames) {
    const textList = document.getElementById('textList');
    textList.innerHTML = ''; // Czyszczenie listy

    textNames.forEach(text => {
        const listItem = createTextListItem(text);
        textList.appendChild(listItem);
    });
}

// Funkcja tworzÄ…ca element listy tekstĂłw
function createTextListItem(text) {
    const listItem = document.createElement('li');
    listItem.className = 'list-group-item';
    listItem.dataset.name = text.name;
    listItem.innerText = text.name;
    listItem.addEventListener('click', () => fetchAndLoadText(text.name));
    return listItem;
}

function updatePaginationControls() {
    const nextPageBtn = document.getElementById('nextPage');
    const prevPageBtn = document.getElementById('prevPage');

    nextPageBtn.disabled = currentPage >= totalPages;
    prevPageBtn.disabled = currentPage <= 1;
}

function nextPage() {
    if (currentPage < totalPages) {
        currentPage++;
        decideWhichTextToLoad();
    }
}

function prevPage() {
    if (currentPage > 1) {
        currentPage--;
        decideWhichTextToLoad();
    }
}

// Filtrowanie tekstĂłw po nazwie
function filterTextsByName() {
    currentPage = 1;
    const query = document.getElementById('searchInput').value.toLowerCase();
    decideWhichTextToLoad();
}

function filterTextsByTag() {
    currentPage = 1;
    const tag = document.getElementById('tagInput').value.toLowerCase();
    decideWhichTextToLoad();
}

/////////////////////////////////////////////////

// #        LOGIKA WYĹšWIETLANIA TEKSTU        #//

/////////////////////////////////////////////////

// Funkcja pobierajÄ…ca i wyĹ›wietlajÄ…ca wybrany tekst
function fetchAndLoadText(textName) {
    selectedWords = [];
    wordCount = "";

    // UsuniÄ™cie podĹ›wietlenia z poprzednio aktywnego elementu
    const previousActiveItem = document.querySelector('.list-group-item.active-text');
    if (previousActiveItem) {
        previousActiveItem.classList.remove('active-text');
    }

    // Znalezienie klikniÄ™tego elementu listy na podstawie nazwy tekstu i dodanie klasy podĹ›wietlenia
    const activeItem = document.querySelector(`li[data-name="${textName}"]`);
    if (activeItem) {
        activeItem.classList.add('active-text');
    }

    if(actionBubble != null){document.body.removeChild(actionBubble);actionBubble = null;} // if exist actionBubble in html remove from html
    fetch(`/user/get_texts_data_for_insert_fot_text?name=${encodeURIComponent(textName)}`)
        .then(response => response.json())
        .then(data => {
            const textData = data.texts[0];
            const wordCount = calculateWordCount(textData);
            const fullTextHtml = generateTextHtml(textData);
            selectedTextName = textName
            updateTextContainer(fullTextHtml); // Aktualizacja kontenera z tekstem
            initializeWordContainer(wordCount); // Inicjalizacja kontenera z rozsypankÄ… sĹ‚Ăłw
            showAlert(`Tekst: "${textName}" zostaĹ‚ zaĹ‚adowany!`, 'success');
        })
        .catch(error => {
            console.error('BĹ‚Ä…d przy pobieraniu tekstu:', error);
            showAlert('BĹ‚Ä…d przy wczytywaniu tekstu.', 'danger');
        });
}

// Funkcja obliczajÄ…ca iloĹ›Ä‡ brakujÄ…cych sĹ‚Ăłw
function calculateWordCount(textData) {
    return textData.sentences.reduce((count, sentence) => {
        sentence.missing_words.forEach(missingWord => {
            const word = missingWord.word;
            count[word] = (count[word] || 0) + 1;
        });
        return count;
    }, {});
}

// Funkcja generujÄ…ca HTML dla caĹ‚ego tekstu
function generateTextHtml(textData) {
    let bufforMissingWord = null; // UĹĽywamy null do sprawdzenia, czy brakujÄ…ce sĹ‚owo zmieniĹ‚o siÄ™

    return textData.sentences.map((sentence, sentenceIndex) => {
        return sentence.english.split(' ').map((word, positionIndex) => {
            const missingWord = sentence.missing_words.find(mw => {
                const isMultiplePositions = Array.isArray(mw.position);
                return isMultiplePositions
                    ? mw.position.includes(positionIndex + 1)
                    : mw.position === positionIndex + 1;
            });

            if (missingWord && (bufforMissingWord === null || bufforMissingWord.word !== missingWord.word)) {
                // JeĹĽeli brakujÄ…ce sĹ‚owo siÄ™ zmieniĹ‚o
                if (bufforMissingWord !== null) {
                    // Dodaj HTML dla poprzedniego brakujÄ…cego sĹ‚owa, jeĹĽeli istnieje
                    const missingWordLength = bufforMissingWord.word.split(' ').length;
                    positionIndex += missingWordLength - 1;
                }
                // Zaktualizuj bufforMissingWord
                bufforMissingWord = missingWord;
                return `<span class="droppable word-button" data-word="${missingWord.word}" data-index="${sentenceIndex}-${positionIndex}">____</span>`;
            }

            const isPartOfMissingWord = sentence.missing_words.some(mw => {
                return Array.isArray(mw.position) ? mw.position.includes(positionIndex + 1) : mw.position === positionIndex + 1;
            });

            if (!isPartOfMissingWord) {
                return `<button class="word-button" data-word="${word}" data-index="${sentenceIndex}-${positionIndex}">${word}</button>`;
            }

            return ''; // JeĹ›li sĹ‚owo jest czÄ™Ĺ›ciÄ… brakujÄ…cego sĹ‚owa, nie generujemy HTML dla niego
        }).join(' ');
    }).join(' ');
}

// Funkcja aktualizujÄ…ca zawartoĹ›Ä‡ kontenera z tekstem
function updateTextContainer(html) {
    textContainer.innerHTML = html;
}

// Funkcja inicjalizujÄ…ca kontener z rozsypankÄ… sĹ‚Ăłw
function initializeWordContainer(wordCount) {
    const usedWords = new Set();
    updateWordContainer(wordCount, usedWords);

    function updateWordContainer(wordCount, usedWords) {
        wordContainer.innerHTML = ''; // Czyszczenie kontenera
        const words = shuffleArray(getAvailableWords(wordCount, usedWords));
        words.forEach(createDraggableWord); // Tworzenie sĹ‚Ăłw do przeciÄ…gania
    }

    // Funkcja zwracajÄ…ca dostÄ™pne sĹ‚owa
    function getAvailableWords(wordCount, usedWords) {
        let words = [];
        Object.keys(wordCount).forEach(word => {
            if (wordCount[word] > 0 && !usedWords.has(word)) {
                for (let i = 0; i < wordCount[word]; i++) {
                    words.push(word);
                }
            }
        });
        return words;
    }

    // Funkcja do losowego przetasowania tablicy
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Funkcja tworzÄ…ca elementy sĹ‚Ăłw do przeciÄ…gania
    function createDraggableWord(word) {
        const wordElement = document.createElement('div');
        wordElement.classList.add('image-option');
        wordElement.innerText = word;
        wordElement.draggable = true;
        wordElement.ondragstart = drag;
        wordContainer.appendChild(wordElement);
    }
}

/////////////////////////////////////////////////

// #    LOGIKA WSTAWIANIA SĹĂ“W W PUSTE POLA   #//

/////////////////////////////////////////////////

// ObsĹ‚uga zaznaczania i odznaczania sĹ‚Ăłw
textContainer.addEventListener('mousedown', function(event) {
    if (event.target.classList.contains('word-button')) {
        isMouseDown = true;
        toggleSelection(event.target);
        updateBubble(event);
    }
});

textContainer.addEventListener('mouseover', function(event) {
    if (isMouseDown && event.target.classList.contains('word-button')) {
        toggleSelection(event.target);
        updateBubble(event);
    }
});

textContainer.addEventListener('mouseup', function(event) {
    isMouseDown = false;
    if (selectedWords.length > 0) {
        updateBubble(event, true);
    }
});

document.addEventListener('mouseup', function() {
    isMouseDown = false;
});

let lastSelectedIndex = -1; // Przechowuje ostatni zaznaczony indeks

function toggleSelection(element) {
    const word = element.dataset.word; // Pobieramy sĹ‚owo z atrybutu data
    const wordIndex = element.dataset.index; // Pobieramy indeks sĹ‚owa

    const [sentenceIndex, positionIndex] = wordIndex.split('-').map(Number);

    // Sprawdzamy, czy element jest juĹĽ zaznaczony (usuwanie zaznaczenia)
    if (element.classList.contains('selected')) {
        element.classList.remove('selected');
        selectedWords = selectedWords.filter(selectedWord => selectedWord !== word);
        lastSelectedIndex = selectedWords.length > 0 ? wordIndex : -1;
        return;
    }

    // JeĹ›li nie ma zaznaczonych sĹ‚Ăłw, zaznacz pierwsze sĹ‚owo
    if (selectedWords.length === 0) {
        element.classList.add('selected');
        selectedWords.push(word);
        lastSelectedIndex = wordIndex;
        return;
    }

    const [lastSentenceIndex, lastPositionIndex] = lastSelectedIndex.split('-').map(Number);

    // Sprawdzenie, czy bieĹĽÄ…cy indeks jest poprawnÄ… kontynuacjÄ… zaznaczenia
    if (sentenceIndex === lastSentenceIndex && positionIndex >= lastPositionIndex) {
        // Zaznaczenie wszystkich sĹ‚Ăłw miÄ™dzy ostatnim zaznaczonym a bieĹĽÄ…cym
        const buttons = [...textContainer.querySelectorAll('.word-button')];
        const startIndex = buttons.findIndex(btn => btn.dataset.index === lastSelectedIndex);
        const endIndex = buttons.findIndex(btn => btn.dataset.index === wordIndex);

        for (let i = startIndex; i <= endIndex; i++) {
            const btn = buttons[i];
            if (!btn.classList.contains('selected')) {
                btn.classList.add('selected');
                selectedWords.push(btn.dataset.word);
            }
        }

        lastSelectedIndex = wordIndex;
        selectedWords = [selectedWords.join(' ')]; // ĹÄ…czymy sĹ‚owa w jednÄ… frazÄ™
    } else {
        showAlert("SĹ‚owa muszÄ… byÄ‡ zaznaczane po kolei!", 'warning');
    }

    if (selectedWords.length === 0 && actionBubble) {
        actionBubble.style.display = 'none';
    }
}

// ObsĹ‚uga przeciÄ…gania i upuszczania
function allowDrop(event) {
    event.preventDefault();
}

function drag(event) {
    event.dataTransfer.setData('text', event.target.innerText);
}

function drop(event) {
    event.preventDefault();
    const draggedWord = event.dataTransfer.getData('text');
    const target = event.target;

    if (target.classList.contains('droppable') && draggedWord === target.dataset.word) {
        target.innerText = draggedWord;
        target.classList.add('correct');
        target.classList.remove('droppable');
        target.classList.add('word-button');

        wordCount[draggedWord]--;
        if (wordCount[draggedWord] <= 0) {
            usedWords.add(draggedWord);
            updateWordContainer();
        }
    }
}

// ObsĹ‚uga urzÄ…dzeĹ„ dotykowych (mobile)
textContainer.addEventListener('touchstart', function(event) {
    if (event.target.classList.contains('word-button')) {
        toggleSelection(event.target);
        updateBubble(event.touches[0]);
    }
});

textContainer.addEventListener('touchmove', function(event) {
    const touch = event.touches[0];
    const element = document.elementFromPoint(touch.clientX, touch.clientY);
    if (element && element.classList.contains('word-button')) {
        toggleSelection(element);
        updateBubble(touch);
    }
});

textContainer.addEventListener('touchend', function(event) {
    if (selectedWords.length > 0) {
        updateBubble(event.changedTouches[0], true);
    }
});

document.addEventListener('dragover', allowDrop);
document.addEventListener('drop', drop);

/////////////////////////////////////////////////

// #     LOGIKA DYMKA ZAZNACZANIA SĹĂ“WAEK     #//

/////////////////////////////////////////////////

function updateBubble(event, finalizePosition = false) {
    const firstSelectedWord = document.querySelector('.selected');
    if (selectedWords.length > 0 && firstSelectedWord) {
        const rect = firstSelectedWord.getBoundingClientRect();
        const x = rect.left;
        const y = rect.top - 40;

        if (!actionBubble) {
            createActionBubble();
        }

        updateBubblePosition(x, y);

    }
}

function createActionBubble() {
    actionBubble = document.createElement('div');
    actionBubble.id = 'action-bubble';
    actionBubble.style.position = 'absolute';
    actionBubble.style.padding = '10px';
    actionBubble.style.border = '1px solid #ccc';
    actionBubble.style.borderRadius = '5px';
    actionBubble.style.backgroundColor = '#fff';
    actionBubble.style.boxShadow = '0px 2px 5px rgba(0,0,0,0.2)';
    actionBubble.innerHTML = `
        <button id="translateButton">TĹ‚umacz</button>
        <button id="selectSentenceButton">Zaznacz caĹ‚e zdanie</button>
        <button id="clearSelectionButton">UsuĹ„ zaznaczenie</button>
        <button id="translateButtonGoogle">Google API</button>
    `;
    document.body.appendChild(actionBubble);
    addEventListeners();
}

function addEventListeners() {
    document.getElementById('translateButton').addEventListener('click', handleTranslate);
    document.getElementById('selectSentenceButton').addEventListener('click', selectEntireSentence);
    document.getElementById('clearSelectionButton').addEventListener('click', clearSelections);
    document.getElementById('translateButtonGoogle').addEventListener('click', handleGoogleTranslate);
}

function handleTranslate() {
    const textToTranslate = selectedWords.join(' ');

    // Wykonywanie fetch do API
    fetch('/user/model_fb_translate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: textToTranslate }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.translatedText) {
            updateTranslationHistory(textToTranslate, data.translatedText);
        } else {
            showAlert('Brak tĹ‚umaczenia', 'warning');
        }
        actionBubble.style.display = 'none';
    })
    .catch(error => {
        console.error('Error:', error);
        showAlert('Brak tĹ‚umaczenia', 'warning');
        actionBubble.style.display = 'none';
    });
}

async function handleGoogleTranslate() {
    console.log("selectedWords", selectedWords);
    const translatedText = await translateText(selectedWords, 'pl'); // PrzetĹ‚umaczenie na polski
    console.log("const translatedText", translatedText);
    updateTranslationHistory(selectedWords, translatedText); // Aktualizacja historii tĹ‚umaczeĹ„
}

function updateBubblePosition(x, y) {
    actionBubble.style.left = `${x}px`;
    actionBubble.style.top = `${y}px`;
    actionBubble.style.display = 'block';
}

// Zbieranie zdania z zaznaczonych sĹ‚Ăłw
function selectEntireSentence() {
    const firstSelectedWord = document.querySelector('.selected');
    if (firstSelectedWord) {
        // ZnajdĹş najbliĹĽszy element .word-button, aby okreĹ›liÄ‡ poczÄ…tek zdania
        const sentenceElement = firstSelectedWord.closest('.card-body').querySelectorAll('.word-button');

        if (sentenceElement) {
            let startIndex = Array.from(sentenceElement).indexOf(firstSelectedWord);
            let selectedSentence = [];

            if (startIndex !== -1) {
                // Zaznacz caĹ‚e zdanie od poczÄ…tkowego do koĹ„cowego indeksu
                for (let i = startIndex; i < sentenceElement.length; i++) {
                    const wordElement = sentenceElement[i];
                    if (wordElement.dataset.index.split('-')[0] !== firstSelectedWord.dataset.index.split('-')[0]) {
                        break;
                    }
                    wordElement.classList.add('selected');
                    selectedSentence.push(wordElement.dataset.word);
                }

                // ZĹ‚ĂłĹĽ zdanie z zaznaczonych sĹ‚Ăłw
                let sentenceString = selectedSentence.join(' ');

                // Szukaj, czy nowe zdanie zawiera siÄ™ w juĹĽ istniejÄ…cych, lub je rozszerza
                let wasUpdated = false;
                selectedWords = selectedWords.map(existingSentence => {
                    // JeĹ›li istnieje juĹĽ fragment nowego zdania w istniejÄ…cym
                    if (sentenceString.startsWith(existingSentence)) {
                        // Dodajemy brakujÄ…cÄ… czÄ™Ĺ›Ä‡ do istniejÄ…cego zdania
                        wasUpdated = true;
                        return existingSentence.split(' ')[0] + sentenceString.slice(existingSentence.length);
                    } else if (existingSentence.startsWith(sentenceString)) {
                        // JeĹ›li caĹ‚e nowe zdanie jest juĹĽ czÄ™Ĺ›ciÄ… istniejÄ…cego, nic nie robimy
                        wasUpdated = true;
                        return existingSentence;
                    }
                });
                // JeĹ›li zdanie nie zostaĹ‚o dodane ani rozszerzone, dodaj nowe zdanie
                if (!wasUpdated) {
                    selectedWords.push(sentenceString);
                }
            }
        }
    }
}

function clearSelections() {
    // Funkcja do usuwania wszystkich zaznaczeĹ„
    document.querySelectorAll('.selected').forEach(word => {
        word.classList.remove('selected');
    });
    selectedWords = [];
    actionBubble.style.display = 'none';
}


/////////////////////////////////////////////////

// #       CZÄĹšÄ† ZARZÄ„DZANIA HISTORIÄ„        #//

/////////////////////////////////////////////////


document.getElementById('save-history-to-file').addEventListener('click', function() {
    const translations = [];

    document.querySelectorAll('#translation-history li').forEach(function(item) {
        const originalText = item.querySelector('.editable').textContent.split(' - ')[0].trim();
        const translatedText = item.querySelector('.editable').textContent.split(' - ')[1].trim();

        translations.push({
            "originalText": originalText,
            "translatedText": translatedText,
            "metadata": {
                "translationSource": "manual"  // WartoĹ›Ä‡ domyĹ›lna, moĹĽna zmieniÄ‡
            }
        });
    });

    fetch('/user/save_history_translations_for_insert_words_to_text?name=' + encodeURIComponent(selectedTextName), {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ translations: translations }),
    })
    .then(response => response.json())
    .then(data => {
        console.log('Success:', data);
        showAlert('Historia tĹ‚umaczeĹ„ zostaĹ‚a pomyĹ›lnie zapisana.', 'success');
    })
    .catch((error) => {
        console.error('Error:', error);
    });
});

// ObsĹ‚uga przycisku wczytywania historii z pliku
document.getElementById('load-history-from-file').addEventListener('click', function() {
    console.log(selectedTextName)
    fetch('/user/load_translation_history_for_insert_wors_to_text?name=' + encodeURIComponent(selectedTextName))
        .then(response => response.json())
        .then(data => {
            const translationHistory = document.getElementById('translation-history');
            translationHistory.innerHTML = '';  // WyczyĹ›Ä‡ obecne elementy listy

            if (data.translations && data.translations.length > 0) {
                data.translations.forEach(function(translation) {
                    updateTranslationHistory(translation.originalText, translation.translatedText);
                });
                showAlert('Historia tĹ‚umaczeĹ„ zostaĹ‚a pomyĹ›lnie wczytana.', 'success');
            } else {
                showAlert('Brak zapisanych tĹ‚umaczeĹ„ dla wybranego pliku.', 'warning');
            }
        })
        .catch((error) => {
            console.error('Error:', error);
            showAlert('WystÄ…piĹ‚ bĹ‚Ä…d podczas wczytywania historii tĹ‚umaczeĹ„.', 'danger');
        });
});

// Funkcja do wykonania zapytania do Google Translate API v1 bez klucza
async function translateText(text, targetLang = 'en') {
    console.log("translateText", text)
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;

    try {
        const response = await fetch(url);
        const data = await response.json();
        showAlert('TĹ‚umaczenie wykonane pomyĹ›lnie');
        return data[0][0][0];  // Zwracany przetĹ‚umaczony tekst
    } catch (error) {
        console.error('BĹ‚Ä…d tĹ‚umaczenia:', error);
        showAlert('BĹ‚Ä…d tĹ‚umaczenia', 'danger');
        return 'BĹ‚Ä…d tĹ‚umaczenia';
    }
}

// Funkcja tworzÄ…ca nowy wpis historii tĹ‚umaczeĹ„
function createNewHistoryEntry(originalText, translatedText) {
    const newEntry = document.createElement('li');
    newEntry.innerHTML = `
        <span class="editable">${originalText} - ${translatedText}</span>
        <button class="delete-btn btn btn-sm btn-danger ml-2">UsuĹ„</button>
        <button class="retranslate-btn btn btn-sm btn-primary ml-2">TĹ‚umacz google</button>
    `;
    return newEntry;
}

// Funkcja dodajÄ…ca wpis do historii
function addEntryToHistory(newEntry) {
    const historyList = document.getElementById('translation-history');
    historyList.appendChild(newEntry);
    //showAlert('Dodano nowe tĹ‚umaczenie');
}

// Funkcja obsĹ‚ugujÄ…ca edytowanie wpisu
function enableEditing(editableSpan) {
    editableSpan.addEventListener('click', function () {
        if (!this.isContentEditable) {
            this.contentEditable = true;
            this.focus();
        }
    });

    editableSpan.addEventListener('blur', function () {
        this.contentEditable = false;
        showAlert('Zapisano zmiany');
    });

    editableSpan.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            this.blur();
        }
    });
}

// Funkcja obsĹ‚ugujÄ…ca usuwanie wpisu
function enableDeletion(deleteButton, newEntry) {
    const historyList = document.getElementById('translation-history');
    deleteButton.addEventListener('click', function() {
        historyList.removeChild(newEntry);
        showAlert('UsuniÄ™to tĹ‚umaczenie', 'info');
    });
}

// Funkcja obsĹ‚ugujÄ…ca ponowne tĹ‚umaczenie
function enableRetranslation(retranslateButton, originalText, editableSpan) {
    retranslateButton.addEventListener('click', async function() {
        console.log("originalText", originalText)
        const newTranslation = await translateText(originalText, 'pl'); // TĹ‚umaczenie na polski
        editableSpan.innerText = `${originalText} - ${newTranslation}`;
        showAlert('Zaktualizowano tĹ‚umaczenie przez Google');
    });
}

// GĹ‚Ăłwna funkcja aktualizujÄ…ca historiÄ™ tĹ‚umaczeĹ„
function updateTranslationHistory(originalText, translatedText) {
    const newEntry = createNewHistoryEntry(originalText, translatedText);
    addEntryToHistory(newEntry);

    const editableSpan = newEntry.querySelector('.editable');
    const deleteButton = newEntry.querySelector('.delete-btn');
    const retranslateButton = newEntry.querySelector('.retranslate-btn');

    enableEditing(editableSpan);
    enableDeletion(deleteButton, newEntry);
    enableRetranslation(retranslateButton, originalText, editableSpan);

    // WyĹ›wietl powiadomienie o dodaniu nowego wpisu do historii
    showAlertOnceInInterval('Nowe wpisy do historii tĹ‚umaczeĹ„ zostaĹ‚y dodane.', 'success');
}

// Funkcja czyszczenia caĹ‚ej historii
document.getElementById('clear-history').addEventListener('click', function() {
    const historyList = document.getElementById('translation-history');
    historyList.innerHTML = ''; // Usuwa wszystkie elementy
    showAlert('Wyczyszczono caĹ‚Ä… historiÄ™', 'warning');
});

</script>
{% endblock %}
