{% extends "learn.html" %}

{% block title %}Multi Learning{% endblock %}

{% block learn %}

<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='project/css/learning.css') }}">

<div class="row justify-content-center">
    <!-- Lewa kolumna z kartą i wyborem słów -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Wybierz odpowiednie słowa i przeciągnij je na właściwe miejsce</h2>
            </div>
            <div class="card-body">
                <p id="text-with-blanks"></p>
                <div id="image-container" class="d-flex justify-content-center flex-wrap"></div>
            </div>
        </div>
    </div>

    <!-- Prawa kolumna z historią tłumaczeń -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Historia tłumaczeń</h2>
            </div>
            <div class="card-body">
                <ul id="translation-history"></ul> <!-- Tutaj będzie wyświetlana historia tłumaczeń -->
                <button id="clear-history" class="btn btn-sm btn-danger mt-3">Wyczyść historię</button>
                <button id="save-history-to-file" class="btn btn-sm btn-success mt-3">Zapisz historię</button>
                <button id="load-history-from-file" class="btn btn-sm btn-primary mt-3">Wczytaj historię</button>
            </div>
            <div class="card-footer text-center">
            <p class="m-0">ENTER = save changes </p>
            </div>
        </div>
    </div>



    <!-- Karta do wyboru tekstu -->
    <div class="card mb-3">
        <div class="card-header text-center">
            <h2 class="card-title">Wybierz tekst do załadowania</h2>
        </div>
        <div class="card-body">
            <ul id="textList" class="list-group">
                <!-- Lista tekstów zostanie wygenerowana dynamicznie -->
            </ul>
        </div>
    </div>

    <!-- Miejsce na dynamiczne powiadomienia (alerty) -->
    <div id="alert-container" style="position: fixed; top: 10px; right: 10px; z-index: 1000;"></div>

</div>

<!-- Modal remains the same -->
<div class="modal fade" id="translationModal" tabindex="-1" aria-labelledby="translationModalLabel" aria-hidden="true">
    <!-- Modal content is the same -->
</div>


{% include 'learning/controls/buttons.html' %}
{% include 'learning/modals/edit-word-modal.html' %}

{% endblock %}

{% block scripts %}
<script>
    
let actionBubble = null;
let selectedTextName = "";
let selectedWords = [];
let wordCount = "";
let alertShown = false;

const textContainer = document.getElementById('text-with-blanks');
const wordContainer = document.getElementById('image-container');

// Funkcja do wyświetlania alertów
function showAlert(message, type = 'success') {
    const alertContainer = document.getElementById('alert-container');
    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.innerText = message;
    alertContainer.appendChild(alert);

    // Usunięcie alertu po 3 sekundach
    setTimeout(() => {
        alert.remove();
    }, 3000);
}

function showAlertOnceInInterval(message, type) {
    if (!alertShown) {
        showAlert(message, type);
        alertShown = true;
        
        // Resetowanie flagi po 5 sekundach
        setTimeout(() => {
            alertShown = false;
        }, 5000); // 5000 milisekund = 5 sekund
    }
}

/////////////////////////////////////////////////

// #        LOGIKA WCZYTYWANIA TEKSTÓW        #//

/////////////////////////////////////////////////

// Główna funkcja inicjalizująca aplikację
document.addEventListener('DOMContentLoaded', () => {
    decideWhichTextToLoad();
});

// Funkcja pobierająca listę tekstów do wyboru
function decideWhichTextToLoad() {
    fetch('/user/get_text_data')
        .then(response => response.json())
        .then(data => {
            populateTextList(data.text_names); // Wyświetlenie listy tekstów
            showAlert('Lista tekstów została załadowana!', 'success');
        })
        .catch(error => {
            console.error('Błąd przy pobieraniu listy tekstów:', error);
            showAlert('Błąd przy pobieraniu listy tekstów.', 'danger');
        });
}

// Funkcja generująca listę tekstów
function populateTextList(textNames) {
    const textList = document.getElementById('textList');
    textList.innerHTML = ''; // Czyszczenie listy przed dodaniem nowych elementów

    textNames.forEach(text => {
        const listItem = createTextListItem(text); // Tworzenie elementów listy <li>
        textList.appendChild(listItem);
    });
}

// Funkcja tworząca element listy tekstów
function createTextListItem(text) {
    const listItem = document.createElement('li');
    listItem.className = 'list-group-item';
    listItem.dataset.name = text.name;
    listItem.innerText = text.name;
    listItem.addEventListener('click', () => fetchAndLoadText(text.name)); // Pobieranie tekstu po kliknięciu
    return listItem;
}

// Funkcja pobierająca i wyświetlająca wybrany tekst
function fetchAndLoadText(textName) {
    selectedWords = [];
    wordCount = "";

    // Usunięcie podświetlenia z poprzednio aktywnego elementu
    const previousActiveItem = document.querySelector('.list-group-item.active-text');
    if (previousActiveItem) {
        previousActiveItem.classList.remove('active-text');
    }

    // Znalezienie klikniętego elementu listy na podstawie nazwy tekstu i dodanie klasy podświetlenia
    const activeItem = document.querySelector(`li[data-name="${textName}"]`);
    if (activeItem) {
        activeItem.classList.add('active-text');
    }

    if(actionBubble != null){document.body.removeChild(actionBubble);actionBubble = null;} // if exist actionBubble in html remove from html
    fetch(`/user/get_text_data?name=${encodeURIComponent(textName)}`)
        .then(response => response.json())
        .then(data => {
            const textData = data.texts[0];
            const wordCount = calculateWordCount(textData);
            const fullTextHtml = generateTextHtml(textData);
            selectedTextName = textName
            updateTextContainer(fullTextHtml); // Aktualizacja kontenera z tekstem
            initializeWordContainer(wordCount); // Inicjalizacja kontenera z rozsypanką słów
            showAlert(`Tekst: "${textName}" został załadowany!`, 'success');
        })
        .catch(error => {
            console.error('Błąd przy pobieraniu tekstu:', error);
            showAlert('Błąd przy wczytywaniu tekstu.', 'danger');
        });
}

// Funkcja obliczająca ilość brakujących słów
function calculateWordCount(textData) {
    return textData.sentences.reduce((count, sentence) => {
        sentence.missing_words.forEach(missingWord => {
            const word = missingWord.word;
            count[word] = (count[word] || 0) + 1;
        });
        return count;
    }, {});
}

// Funkcja generująca HTML dla całego tekstu
function generateTextHtml(textData) {
    return textData.sentences.map((sentence, sentenceIndex) => {
        return sentence.english.split(' ').map((word, positionIndex) => {
            const missingWord = sentence.missing_words.find(mw => {
                const isMultiplePositions = Array.isArray(mw.position);
                return isMultiplePositions
                    ? mw.position.includes(positionIndex + 1)
                    : mw.position === positionIndex + 1;
            });

            if (missingWord) {
                const missingWordLength = missingWord.word.split(' ').length;
                positionIndex += missingWordLength - 1;
                return `<span class="droppable word-button" data-word="${missingWord.word}" data-index="${sentenceIndex}-${positionIndex}">____</span>`;
            }

            const isPartOfMissingWord = sentence.missing_words.some(mw => {
                return Array.isArray(mw.position) && mw.position.includes(positionIndex + 1);
            });

            return !isPartOfMissingWord ? `<button class="word-button" data-word="${word}" data-index="${sentenceIndex}-${positionIndex}">${word}</button>` : '';
        }).join(' ');
    }).join(' ');
}

// Funkcja aktualizująca zawartość kontenera z tekstem
function updateTextContainer(html) {
    textContainer.innerHTML = html;
}

// Funkcja inicjalizująca kontener z rozsypanką słów
function initializeWordContainer(wordCount) {
    const usedWords = new Set();
    updateWordContainer(wordCount, usedWords);

    function updateWordContainer(wordCount, usedWords) {
        wordContainer.innerHTML = ''; // Czyszczenie kontenera
        const words = shuffleArray(getAvailableWords(wordCount, usedWords));
        words.forEach(createDraggableWord); // Tworzenie słów do przeciągania
    }

    // Funkcja zwracająca dostępne słowa
    function getAvailableWords(wordCount, usedWords) {
        let words = [];
        Object.keys(wordCount).forEach(word => {
            if (wordCount[word] > 0 && !usedWords.has(word)) {
                for (let i = 0; i < wordCount[word]; i++) {
                    words.push(word);
                }
            }
        });
        return words;
    }

    // Funkcja do losowego przetasowania tablicy
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Funkcja tworząca elementy słów do przeciągania
    function createDraggableWord(word) {
        const wordElement = document.createElement('div');
        wordElement.classList.add('image-option');
        wordElement.innerText = word;
        wordElement.draggable = true;
        wordElement.ondragstart = drag;
        wordContainer.appendChild(wordElement);
    }
}

/////////////////////////////////////////////////

// #    LOGIKA WSTAWIANIA SŁÓW W PUSTE POLA   #//

/////////////////////////////////////////////////

// Obsługa zaznaczania i odznaczania słów
textContainer.addEventListener('mousedown', function(event) {
    if (event.target.classList.contains('word-button')) {
        isMouseDown = true;
        toggleSelection(event.target);
        updateBubble(event);
    }
});

textContainer.addEventListener('mouseover', function(event) {
    if (isMouseDown && event.target.classList.contains('word-button')) {
        toggleSelection(event.target);
        updateBubble(event);
    }
});

textContainer.addEventListener('mouseup', function(event) {
    isMouseDown = false;
    if (selectedWords.length > 0) {
        updateBubble(event, true);
    }
});

document.addEventListener('mouseup', function() {
    isMouseDown = false;
});

function toggleSelection(element) {
    const word = element.dataset.word; // Pobieramy słowo z atrybutu data
    const wordIndex = element.dataset.index; // Pobieramy indeks słowa

    // Jeśli selectedWords jest puste lub obecne słowo jest następne w kolejności
    if (selectedWords.length === 0 || wordIndex === `${lastSelectedIndex.split('-')[0]}-${parseInt(lastSelectedIndex.split('-')[1]) + 1}`) {
        element.classList.add('selected'); // Dodajemy klasę "selected"
        
        // Łączymy słowa w jedno zdanie (dołączamy kolejne słowo z odstępem)
        selectedWords = selectedWords.length > 0 ? [selectedWords.join(' ') + ' ' + word] : [word];
        
        lastSelectedIndex = wordIndex; // Aktualizujemy ostatni indeks
    } else if (element.classList.contains('selected')) {
        element.classList.remove('selected'); // Usuwamy klasę "selected"
        
        // Usuwamy dane słowo ze zdania (jeśli istnieje)
        selectedWords = [selectedWords[0].replace(word, '').trim()];
        
        lastSelectedIndex = selectedWords.length > 0 ? element.dataset.index : -1;
    }

    // Ukrywamy actionBubble, jeśli nie ma wybranych słów
    if (selectedWords.length === 0 && actionBubble) {
        actionBubble.style.display = 'none';
    }
}

// Obsługa przeciągania i upuszczania
function allowDrop(event) {
    event.preventDefault();
}

function drag(event) {
    event.dataTransfer.setData('text', event.target.innerText);
}

function drop(event) {
    event.preventDefault();
    const draggedWord = event.dataTransfer.getData('text');
    const target = event.target;

    if (target.classList.contains('droppable') && draggedWord === target.dataset.word) {
        target.innerText = draggedWord;
        target.classList.add('correct');
        target.classList.remove('droppable');
        target.classList.add('word-button');

        wordCount[draggedWord]--;
        if (wordCount[draggedWord] <= 0) {
            usedWords.add(draggedWord);
            updateWordContainer();
        }
    }
}

// Obsługa urządzeń dotykowych (mobile)
textContainer.addEventListener('touchstart', function(event) {
    if (event.target.classList.contains('word-button')) {
        toggleSelection(event.target);
        updateBubble(event.touches[0]);
    }
});

textContainer.addEventListener('touchmove', function(event) {
    const touch = event.touches[0];
    const element = document.elementFromPoint(touch.clientX, touch.clientY);
    if (element && element.classList.contains('word-button')) {
        toggleSelection(element);
        updateBubble(touch);
    }
});

textContainer.addEventListener('touchend', function(event) {
    if (selectedWords.length > 0) {
        updateBubble(event.changedTouches[0], true);
    }
});

document.addEventListener('dragover', allowDrop);
document.addEventListener('drop', drop);

/////////////////////////////////////////////////

// #     LOGIKA DYMKA ZAZNACZANIA SŁÓWAEK     #//

/////////////////////////////////////////////////

function updateBubble(event, finalizePosition = false) {
    const firstSelectedWord = document.querySelector('.selected');
    if (selectedWords.length > 0 && firstSelectedWord) {
        const rect = firstSelectedWord.getBoundingClientRect();
        const x = rect.left;
        const y = rect.top - 40;

        if (!actionBubble) {
            createActionBubble();
        }

        updateBubblePosition(x, y);

    }
}

function createActionBubble() {
    actionBubble = document.createElement('div');
    actionBubble.id = 'action-bubble';
    actionBubble.style.position = 'absolute';
    actionBubble.style.padding = '10px';
    actionBubble.style.border = '1px solid #ccc';
    actionBubble.style.borderRadius = '5px';
    actionBubble.style.backgroundColor = '#fff';
    actionBubble.style.boxShadow = '0px 2px 5px rgba(0,0,0,0.2)';
    actionBubble.innerHTML = `
        <button id="translateButton">Tłumacz</button>
        <button id="selectSentenceButton">Zaznacz całe zdanie</button>
        <button id="clearSelectionButton">Usuń zaznaczenie</button>
        <button id="translateButtonGoogle">Google API</button>
    `;
    document.body.appendChild(actionBubble);
    addEventListeners();
}

function addEventListeners() {
    document.getElementById('translateButton').addEventListener('click', handleTranslate);
    document.getElementById('selectSentenceButton').addEventListener('click', selectEntireSentence);
    document.getElementById('clearSelectionButton').addEventListener('click', clearSelections);
    document.getElementById('translateButtonGoogle').addEventListener('click', handleGoogleTranslate);
}

function handleTranslate() {
    const textToTranslate = selectedWords.join(' ');

    // Wykonywanie fetch do API
    fetch('/user/translate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: textToTranslate }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.translatedText) {
            updateTranslationHistory(textToTranslate, data.translatedText);
        } else {
            showAlert('Brak tłumaczenia', 'warning');
        }
        actionBubble.style.display = 'none';
    })
    .catch(error => {
        console.error('Error:', error);
        showAlert('Brak tłumaczenia', 'warning');
        actionBubble.style.display = 'none';
    });
}

async function handleGoogleTranslate() {
    console.log("selectedWords", selectedWords);
    const translatedText = await translateText(selectedWords, 'pl'); // Przetłumaczenie na polski
    console.log("const translatedText", translatedText);
    updateTranslationHistory(selectedWords, translatedText); // Aktualizacja historii tłumaczeń
}

function updateBubblePosition(x, y) {
    actionBubble.style.left = `${x}px`;
    actionBubble.style.top = `${y}px`;
    actionBubble.style.display = 'block';
}

// Zbieranie zdania z zaznaczonych słów
function selectEntireSentence() {
    const firstSelectedWord = document.querySelector('.selected');
    if (firstSelectedWord) {
        // Znajdź najbliższy element .word-button, aby określić początek zdania
        const sentenceElement = firstSelectedWord.closest('.card-body').querySelectorAll('.word-button');

        if (sentenceElement) {
            let startIndex = Array.from(sentenceElement).indexOf(firstSelectedWord);
            let selectedSentence = [];

            if (startIndex !== -1) {
                // Zaznacz całe zdanie od początkowego do końcowego indeksu
                for (let i = startIndex; i < sentenceElement.length; i++) {
                    const wordElement = sentenceElement[i];
                    if (wordElement.dataset.index.split('-')[0] !== firstSelectedWord.dataset.index.split('-')[0]) {
                        break;
                    }
                    wordElement.classList.add('selected');
                    selectedSentence.push(wordElement.dataset.word);
                }

                // Złóż zdanie z zaznaczonych słów
                let sentenceString = selectedSentence.join(' ');

                // Szukaj, czy nowe zdanie zawiera się w już istniejących, lub je rozszerza
                let wasUpdated = false;
                selectedWords = selectedWords.map(existingSentence => {
                    // Jeśli istnieje już fragment nowego zdania w istniejącym
                    if (sentenceString.startsWith(existingSentence)) {
                        // Dodajemy brakującą część do istniejącego zdania
                        wasUpdated = true;
                        return existingSentence.split(' ')[0] + sentenceString.slice(existingSentence.length);
                    } else if (existingSentence.startsWith(sentenceString)) {
                        // Jeśli całe nowe zdanie jest już częścią istniejącego, nic nie robimy
                        wasUpdated = true;
                        return existingSentence;
                    }
                });
                // Jeśli zdanie nie zostało dodane ani rozszerzone, dodaj nowe zdanie
                if (!wasUpdated) {
                    selectedWords.push(sentenceString);
                }
            }
        }
    }
}

function clearSelections() {
    // Funkcja do usuwania wszystkich zaznaczeń
    document.querySelectorAll('.selected').forEach(word => {
        word.classList.remove('selected');
    });
    selectedWords = [];
    actionBubble.style.display = 'none';
}


/////////////////////////////////////////////////

// #       CZĘŚĆ ZARZĄDZANIA HISTORIĄ        #//

/////////////////////////////////////////////////


document.getElementById('save-history-to-file').addEventListener('click', function() {
    const translations = [];

    document.querySelectorAll('#translation-history li').forEach(function(item) {
        const originalText = item.querySelector('.editable').textContent.split(' - ')[0].trim();
        const translatedText = item.querySelector('.editable').textContent.split(' - ')[1].trim();

        translations.push({
            "originalText": originalText,
            "translatedText": translatedText,
            "metadata": {
                "translationSource": "manual"  // Wartość domyślna, można zmienić
            }
        });
    });

    fetch('/user/save_history_translation?name=' + encodeURIComponent(selectedTextName), {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ translations: translations }),
    })
    .then(response => response.json())
    .then(data => {
        console.log('Success:', data);
        showAlert('Historia tłumaczeń została pomyślnie zapisana.', 'success');
    })
    .catch((error) => {
        console.error('Error:', error);
    });
});

// Obsługa przycisku wczytywania historii z pliku
document.getElementById('load-history-from-file').addEventListener('click', function() {
    console.log(selectedTextName)
    fetch('/user/load_translation_history_from_file?name=' + encodeURIComponent(selectedTextName))
        .then(response => response.json())
        .then(data => {
            const translationHistory = document.getElementById('translation-history');
            translationHistory.innerHTML = '';  // Wyczyść obecne elementy listy

            if (data.translations && data.translations.length > 0) {
                data.translations.forEach(function(translation) {
                    updateTranslationHistory(translation.originalText, translation.translatedText);
                });
                showAlert('Historia tłumaczeń została pomyślnie wczytana.', 'success');
            } else {
                showAlert('Brak zapisanych tłumaczeń dla wybranego pliku.', 'warning');
            }
        })
        .catch((error) => {
            console.error('Error:', error);
            showAlert('Wystąpił błąd podczas wczytywania historii tłumaczeń.', 'danger');
        });
});

// Funkcja do wykonania zapytania do Google Translate API v1 bez klucza
async function translateText(text, targetLang = 'en') {
    console.log("translateText", text)
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;

    try {
        const response = await fetch(url);
        const data = await response.json();
        showAlert('Tłumaczenie wykonane pomyślnie');
        return data[0][0][0];  // Zwracany przetłumaczony tekst
    } catch (error) {
        console.error('Błąd tłumaczenia:', error);
        showAlert('Błąd tłumaczenia', 'danger');
        return 'Błąd tłumaczenia';
    }
}

// Funkcja tworząca nowy wpis historii tłumaczeń
function createNewHistoryEntry(originalText, translatedText) {
    const newEntry = document.createElement('li');
    newEntry.innerHTML = `
        <span class="editable">${originalText} - ${translatedText}</span>
        <button class="delete-btn btn btn-sm btn-danger ml-2">Usuń</button>
        <button class="retranslate-btn btn btn-sm btn-primary ml-2">Tłumacz google</button>
    `;
    return newEntry;
}

// Funkcja dodająca wpis do historii
function addEntryToHistory(newEntry) {
    const historyList = document.getElementById('translation-history');
    historyList.appendChild(newEntry);
    //showAlert('Dodano nowe tłumaczenie');
}

// Funkcja obsługująca edytowanie wpisu
function enableEditing(editableSpan) {
    editableSpan.addEventListener('click', function () {
        if (!this.isContentEditable) {
            this.contentEditable = true;
            this.focus();
        }
    });

    editableSpan.addEventListener('blur', function () {
        this.contentEditable = false;
        showAlert('Zapisano zmiany');
    });

    editableSpan.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            this.blur();
        }
    });
}

// Funkcja obsługująca usuwanie wpisu
function enableDeletion(deleteButton, newEntry) {
    const historyList = document.getElementById('translation-history');
    deleteButton.addEventListener('click', function() {
        historyList.removeChild(newEntry);
        showAlert('Usunięto tłumaczenie', 'info');
    });
}

// Funkcja obsługująca ponowne tłumaczenie
function enableRetranslation(retranslateButton, originalText, editableSpan) {
    retranslateButton.addEventListener('click', async function() {
        console.log("originalText", originalText)
        const newTranslation = await translateText(originalText, 'pl'); // Tłumaczenie na polski
        editableSpan.innerText = `${originalText} - ${newTranslation}`;
        showAlert('Zaktualizowano tłumaczenie przez Google');
    });
}

// Główna funkcja aktualizująca historię tłumaczeń
function updateTranslationHistory(originalText, translatedText) {
    const newEntry = createNewHistoryEntry(originalText, translatedText);
    addEntryToHistory(newEntry);

    const editableSpan = newEntry.querySelector('.editable');
    const deleteButton = newEntry.querySelector('.delete-btn');
    const retranslateButton = newEntry.querySelector('.retranslate-btn');

    enableEditing(editableSpan);
    enableDeletion(deleteButton, newEntry);
    enableRetranslation(retranslateButton, originalText, editableSpan);

    // Wyświetl powiadomienie o dodaniu nowego wpisu do historii
    showAlertOnceInInterval('Nowe wpisy do historii tłumaczeń zostały dodane.', 'success');
}

// Funkcja czyszczenia całej historii
document.getElementById('clear-history').addEventListener('click', function() {
    const historyList = document.getElementById('translation-history');
    historyList.innerHTML = ''; // Usuwa wszystkie elementy
    showAlert('Wyczyszczono całą historię', 'warning');
});

</script>
{% endblock %}
