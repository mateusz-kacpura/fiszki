<!-- Napisz projekt gry słownej, gdzie zadaniem użytkownika będzie połączenie słów z odpowiadającymi im synonimami w pary z losowej rozsypanki wyrazów, gdzie po jednej stronie będą słowa a po drugiej synonimy -->

{% extends "learn.html" %}

{% block title %}Multi Learning{% endblock %}

{% block learn %}

<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='project/css/learning.css') }}">

<div class="row justify-content-center">
    <!-- Lewa kolumna z wyborem słów -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Połącz słowa z ich definicjami</h2>
            </div>
            <canvas id="wordCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <!-- Prawa kolumna z pomocą -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Pomoc</h2>
            </div>
            <div class="card-body">
                
            </div>
            <div class="card-footer text-center">
                <!-- Dodatkowe kontrolki lub informacje -->
            </div>
        </div>
    </div>

    <!-- Miejsce na dynamiczne powiadomienia (alerty) -->
    <div id="alert-container" style="position: fixed; top: 10px; right: 10px; z-index: 1000;"></div>

</div>

{% include 'learning/controls/buttons.html' %}
{% include 'learning/modals/edit-word-modal.html' %}

{% endblock %}

{% block scripts %}
<script>
const canvas = document.getElementById("wordCanvas");
const ctx = canvas.getContext("2d");

fetch('/user/get_synonim_data?game_name=Synonym Match')
    .then(response => response.json())
    .then(data => {
        initializeGame(data[0].pairs); 
    })
    .catch(error => console.error('Błąd:', error));

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const wordRadius = 50;
const leftAreaWidth = canvasWidth / 2;
const rightAreaWidth = canvasWidth / 2;
const leftAreaX = wordRadius;
const rightAreaX = canvasWidth / 2 + wordRadius;
const verticalSpacing = wordRadius * 2 + 20;  // 20 to dodatkowa przestrzeń między słowami

let words = [];
let synonyms = [];
let connections = [];
let draggingLine = false; 
let startX = 0, startY = 0;  
let currentWord = null;  

function isOverlapping(word1, word2) {
    const dx = word1.x - word2.x;
    const dy = word1.y - word2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < word1.radius + word2.radius;
}

function initializeGame(pairs) {
    pairs.forEach((pair, index) => {
        const wordY = verticalSpacing * index + wordRadius;
        if (wordY + wordRadius > canvasHeight) {
            console.error("Zbyt wiele par dla danego płótna.");
            return;
        }

        const word = {
            x: leftAreaX,
            y: wordY,
            radius: wordRadius,
            text: pair.word,
            pairIndex: index,
            color: "#FFD700"
        };
        words.push(word);

        const synonym = {
            x: rightAreaX,
            y: wordY,
            radius: wordRadius,
            text: pair.synonym,
            pairIndex: index,
            color: "#ADFF2F"
        };
        synonyms.push(synonym);
    });
    drawWords();
}

function createNonOverlappingPosition(areaWidth, offset, text, index, color) {
    let position;
    let maxAttempts = 100;
    let attempts = 0;

    do {
        position = {
            x: Math.random() * (areaWidth - 2 * wordRadius) + offset + wordRadius,
            y: Math.random() * (canvasHeight - 2 * wordRadius) + wordRadius,
            radius: wordRadius,
            text: text,
            pairIndex: index,
            color: color
        };
        attempts++;
    } while (isOverlappingAny(position) && attempts < maxAttempts);

    return position;
}

function isOverlappingAny(word) {
    return [...words, ...synonyms].some(existingWord => isOverlapping(word, existingWord));
}

function drawConnectionPoints(word) {
    const radius = 5; 
    ctx.beginPath();
    
    if (words.includes(word)) { 
        // Draw point at the right edge of the word's rectangle
        ctx.arc(word.x + word.radius + radius, word.y, radius, 0, 2 * Math.PI);
    } else if (synonyms.includes(word)) {  
        // Draw point at the left edge of the synonym's rectangle
        ctx.arc(word.x - word.radius - radius, word.y, radius, 0, 2 * Math.PI);
    }
    
    ctx.fillStyle = "#FFF"; 
    ctx.fill();
    ctx.strokeStyle = "#000"; // Color of the border
    ctx.stroke();
}


function drawCross(x, y, size = 10) {
    // Rysowanie białego kółka wokół krzyżyka
    const circleRadius = size * 0.75;  // Ustal promień białego kółka
    ctx.beginPath();
    ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
    ctx.fillStyle = "#FFF";  // Białe kółko
    ctx.fill();
    ctx.strokeStyle = "#000";  // Czarny obrys kółka
    ctx.lineWidth = 1;
    ctx.stroke();

    // Rysowanie krzyżyka
    ctx.beginPath();
    ctx.moveTo(x - size / 2, y - size / 2);
    ctx.lineTo(x + size / 2, y + size / 2);
    ctx.moveTo(x + size / 2, y - size / 2);
    ctx.lineTo(x - size / 2, y + size / 2);
    ctx.strokeStyle = "#FF0000";  // Czerwony krzyżyk
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawWords() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);  // Wyczyść canvas

    // Rysowanie linii połączeń
    connections.forEach(connection => {
        ctx.beginPath();
        ctx.moveTo(connection.word.x + wordRadius, connection.word.y);
        ctx.lineTo(connection.synonym.x - wordRadius, connection.synonym.y);
        ctx.strokeStyle = connection.correct ? "green" : "red";  // Kolor linii
        ctx.lineWidth = 3;  
        ctx.stroke();

        // Rysowanie krzyżyka na środku linii
        const midX = (connection.word.x + wordRadius + connection.synonym.x - wordRadius) / 2;
        const midY = (connection.word.y + connection.synonym.y) / 2;
        drawCross(midX, midY);
    });

    // Funkcja rysująca słowa i synonimy
    [...words, ...synonyms].forEach(word => {
        ctx.font = "16px Arial";
        const textWidth = ctx.measureText(word.text).width;
        const textHeight = 16; // Wysokość czcionki

        // Ustawienia marginesów
        const margin = 10; // Margines w pikselach
        const rectWidth = textWidth + 2 * margin;
        const rectHeight = textHeight + 2 * margin;

        // Obliczanie położenia prostokąta względem koła
        let rectX, rectY;
        if (words.includes(word)) { 
            rectX = word.x - word.radius - rectWidth;
            rectY = word.y - rectHeight / 2;
        } else if (synonyms.includes(word)) {  
            rectX = word.x + word.radius;
            rectY = word.y - rectHeight / 2;
        }

        // Rysowanie prostokąta
        ctx.beginPath();
        ctx.rect(word.x - rectWidth / 2, word.y - rectHeight / 2, rectWidth, rectHeight);
        ctx.strokeStyle = word.color; // Kolor obramowania
        ctx.lineWidth = 2; // Grubość linii obramowania
        ctx.stroke();

        // Rysowanie tekstu
        ctx.fillStyle = "#000"; // Kolor tekstu
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(word.text, word.x, word.y);

        // Rysowanie punktów połączeń
        drawConnectionPoints(word);
    });
}


function getConnectionPointAtPosition(x, y, wordList) {
    return wordList.find(word => {
        if (words.includes(word)) {
            // Check if the point is near the right edge of the rectangle
            const dx = x - (word.x + word.radius + 5); // Adjust for the radius of the connection point
            const dy = y - word.y;
            return Math.sqrt(dx * dx + dy * dy) < 5;
        } else if (synonyms.includes(word)) {
            // Check if the point is near the left edge of the rectangle
            const dx = x - (word.x - word.radius - 5); // Adjust for the radius of the connection point
            const dy = y - word.y;
            return Math.sqrt(dx * dx + dy * dy) < 5;
        }
    });
}


let selectedWord = null;
let selectedSynonym = null;

function getWordAtPosition(x, y, wordList) {
    return wordList.find(word => {
        const dx = x - word.x;
        const dy = y - word.y;
        return Math.sqrt(dx * dx + dy * dy) < word.radius;
    });
}

canvas.addEventListener("mousedown", (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    const clickedWord = getWordAtPosition(mouseX, mouseY, words);
    const clickedSynonym = getWordAtPosition(mouseX, mouseY, synonyms);

    if (clickedWord) {
        currentWord = clickedWord;
        startX = clickedWord.x;
        startY = clickedWord.y;
        draggingLine = true;
    } 
    else if (clickedSynonym) {
        currentWord = clickedSynonym;
        startX = clickedSynonym.x;
        startY = clickedSynonym.y;
        draggingLine = true;
    }
});


function makeConnection(word, synonym) {
    const existingConnection = connections.find(connection => connection.word === word || connection.synonym === synonym);

    if (existingConnection) {
        connections = connections.filter(connection => connection !== existingConnection);
    }

    const correct = word.pairIndex === synonym.pairIndex;

    connections.push({
        word: word,
        synonym: synonym,
        correct: correct
    });
}

canvas.addEventListener("mousemove", (e) => {
    if (draggingLine && currentWord) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        drawWords();  

        ctx.beginPath();
        
        if (words.includes(currentWord)) {
            ctx.moveTo(currentWord.x + currentWord.radius, currentWord.y);
        } else {
            ctx.moveTo(currentWord.x - currentWord.radius, currentWord.y);
        }

        ctx.lineTo(mouseX, mouseY);
        
        ctx.strokeStyle = "#000";  
        ctx.lineWidth = 2; 
        ctx.stroke();
    }
});

canvas.addEventListener("mouseup", (e) => {
    if (draggingLine && currentWord) {
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;

        if (currentWord && currentWord.x < leftAreaWidth) {
            const targetSynonym = getWordAtPosition(mouseX, mouseY, synonyms);
            if (targetSynonym) {
                makeConnection(currentWord, targetSynonym);
            }
        } else {
            const targetWord = getWordAtPosition(mouseX, mouseY, words);
            if (targetWord) {
                makeConnection(targetWord, currentWord);
            }
        }

        draggingLine = false;
        currentWord = null;
        drawWords(); 
    }
});

canvas.addEventListener("mouseup", (e) => {
    if (draggingLine && currentWord) {
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;

        // Determine if the mouse is released over a valid connection point
        const targetWord = getConnectionPointAtPosition(mouseX, mouseY, words);
        const targetSynonym = getConnectionPointAtPosition(mouseX, mouseY, synonyms);

        if (targetWord && synonyms.includes(currentWord)) {
            makeConnection(targetWord, currentWord); 
        } else if (targetSynonym && words.includes(currentWord)) {
            makeConnection(currentWord, targetSynonym);  
        }

        draggingLine = false;
        currentWord = null;  
        drawWords();  
    }
});

function isClickOnCross(x, y, connection) {
    const midX = (connection.word.x + wordRadius + connection.synonym.x - wordRadius) / 2;
    const midY = (connection.word.y + connection.synonym.y) / 2;

    const dx = x - midX;
    const dy = y - midY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    return distance < 15;
}

canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    const clickedConnection = connections.find(connection => isClickOnCross(mouseX, mouseY, connection));

    if (clickedConnection) {
        connections = connections.filter(connection => connection !== clickedConnection);
        drawWords();
    }
});


function pointLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    const param = (len_sq !== 0) ? (dot / len_sq) : -1;

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function getConnectionAtPosition(x, y) {
    return connections.find(connection => {
        const distToLine = pointLineDistance(x, y, connection.word.x, connection.word.y, connection.synonym.x, connection.synonym.y);
        return distToLine < 5; 
    });
}

</script>
{% endblock %}
