<!-- Napisz projekt gry słownej, gdzie zadaniem użytkownika będzie połączenie słów z odpowiadającymi im synonimami w pary z losowej rozsypanki wyrazów, gdzie po jednej stronie będą słowa, a po drugiej synonimy -->

{% extends "learn.html" %}

{% block title %}Multi Learning{% endblock %}

{% block learn %}

<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='project/css/learning.css') }}">
<style>
    #canvasContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #wordCanvas {
        border: 1px solid #000;
    }
</style>
<div class="row justify-content-center">
    <!-- Lewa kolumna z wyborem słów -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Połącz słowa z ich definicjami</h2>
            </div>
            <canvas id="wordCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <!-- Prawa kolumna z pomocą -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header text-center">
                <h2 class="card-title">Pomoc</h2>
            </div>
            <div class="card-body">
            </div>
            <div class="card-footer text-center">
                <!-- Dodatkowe kontrolki lub informacje -->
                Możesz połączyć ze sobą środki wyrażeń
            </div>
        </div>
    </div>

    <!-- Miejsce na dynamiczne powiadomienia (alerty) -->
    <div id="alert-container" style="position: fixed; top: 10px; right: 10px; z-index: 1000;"></div>

</div>

{% include 'learning/controls/buttons.html' %}
{% include 'learning/modals/edit-word-modal.html' %}

{% endblock %}

{% block scripts %}
<script>
const canvas = document.getElementById("wordCanvas");
const ctx = canvas.getContext("2d");

let canvasWidth = canvas.width;
let canvasHeight = canvas.height;
const wordHeight = 50; // Zmieniono z wordRadius na wordHeight
const leftMargin = 30; // Margines od lewej krawędzi
const rightMargin = 30; // Margines od prawej krawędzi
const verticalSpacing = wordHeight + 10;

let words = [];
let synonyms = [];
let connections = [];
let draggingLine = false;
let currentWord = null;
let pairs = []; // Zmienna globalna przechowująca pary słów

function resizeCanvas() {
    const newWidth = parseInt(document.getElementById('widthInput').value, 10);
    const newHeight = parseInt(document.getElementById('heightInput').value, 10);

    if (newWidth > 0 && newHeight > 0) {
        canvasWidth = newWidth;
        canvasHeight = newHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Aktualizuj rozmieszczenie słów po zmianie rozmiaru płótna
        initializeGame(pairs);
    } else {
        alert('Wprowadź prawidłowe wartości szerokości i wysokości.');
    }
}

fetch('/user/get_synonim_data?game_name=Synonym Match')
    .then(response => response.json())
    .then(data => {
        if (data && data[0] && data[0].pairs) {
            pairs = data[0].pairs.map((pair, index) => ({ ...pair, id: index }));
            initializeGame(pairs);
        } else {
            console.error('Nieprawidłowe dane z serwera:', data);
        }
    })
    .catch(error => console.error('Błąd:', error));

function initializeGame(pairsData) {
    words = [];
    synonyms = [];
    connections = [];

    // Rozdziel pary na słowa i definicje (synonimy)
    const wordObjects = pairsData.map((pair, index) => ({
        text: pair.word,
        id: index
    }));

    const synonymObjects = pairsData.map((pair, index) => ({
        text: pair.synonym,
        id: index
    }));

    // Pomieszaj słowa i definicje niezależnie
    const shuffledWords = shuffleArray(wordObjects);
    const shuffledSynonyms = shuffleArray(synonymObjects);

    ctx.font = "16px Arial";
    const margin = 10;

    // Ustaw pozycje słów po lewej stronie
    shuffledWords.forEach((wordObj, index) => {
        const textWidth = ctx.measureText(wordObj.text).width;
        const textHeight = 16; // Wysokość czcionki
        const rectWidth = textWidth + 2 * margin;
        const rectHeight = textHeight + 2 * margin;

        const wordY = verticalSpacing * index + wordHeight;

        if (wordY + wordHeight > canvasHeight) {
            console.error("Zbyt wiele par dla danego płótna.");
            return;
        }

        const wordX = leftMargin + rectWidth / 2;

        const word = {
            x: wordX,
            y: wordY,
            text: wordObj.text,
            id: wordObj.id,
            color: "#FFD700",
            rectWidth: rectWidth,
            rectHeight: rectHeight
        };

        words.push(word);
    });

    // Ustaw pozycje definicji (synonimów) po prawej stronie
    shuffledSynonyms.forEach((synonymObj, index) => {
        const textWidth = ctx.measureText(synonymObj.text).width;
        const textHeight = 16; // Wysokość czcionki
        const rectWidth = textWidth + 2 * margin;
        const rectHeight = textHeight + 2 * margin;

        const synonymY = verticalSpacing * index + wordHeight;

        if (synonymY + wordHeight > canvasHeight) {
            console.error("Zbyt wiele par dla danego płótna.");
            return;
        }

        const synonymX = canvasWidth - rightMargin - rectWidth / 2;

        const synonym = {
            x: synonymX,
            y: synonymY,
            text: synonymObj.text,
            id: synonymObj.id,
            color: "#ADFF2F",
            rectWidth: rectWidth,
            rectHeight: rectHeight
        };

        synonyms.push(synonym);
    });

    drawWords();
}

// Funkcja do mieszania tablicy
function shuffleArray(array) {
    return array
        .map(value => ({ value, sortKey: Math.random() }))
        .sort((a, b) => a.sortKey - b.sortKey)
        .map(({ value }) => value);
}

function drawWords() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);  // Wyczyść płótno

    // Rysuj połączenia
    connections.forEach(connection => {
        ctx.beginPath();
        ctx.moveTo(getWordRightEdge(connection.word), connection.word.y);
        ctx.lineTo(getWordLeftEdge(connection.synonym), connection.synonym.y);

        ctx.strokeStyle = connection.correct ? "green" : "red";  // Kolor linii
        ctx.lineWidth = 3;  
        ctx.stroke();

        // Rysuj krzyżyk w środku linii
        const midX = (getWordRightEdge(connection.word) + getWordLeftEdge(connection.synonym)) / 2;
        const midY = (connection.word.y + connection.synonym.y) / 2;
        drawCross(midX, midY);
    });

    // Rysuj słowa i synonimy
    ctx.font = "16px Arial";

    [...words, ...synonyms].forEach(word => {
        const rectWidth = word.rectWidth;
        const rectHeight = word.rectHeight;

        const rectX = word.x - rectWidth / 2;
        const rectY = word.y - rectHeight / 2;

        // Rysuj prostokąt
        ctx.beginPath();
        ctx.rect(rectX, rectY, rectWidth, rectHeight);
        ctx.strokeStyle = word.color; // Kolor obramowania
        ctx.lineWidth = 2; // Szerokość obramowania
        ctx.stroke();

        // Rysuj tekst
        ctx.fillStyle = "#000"; // Kolor tekstu
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(word.text, word.x, word.y);

        // Rysuj punkty połączeń
        drawConnectionPoints(word);
    });
}

function getWordRightEdge(word) {
    return word.x + word.rectWidth / 2;
}

function getWordLeftEdge(word) {
    return word.x - word.rectWidth / 2;
}

function drawConnectionPoints(word) {
    const radius = 5; // Promień punktu połączenia
    ctx.beginPath();

    if (words.includes(word)) { 
        // Rysuj punkt po prawej stronie prostokąta słowa
        ctx.arc(getWordRightEdge(word), word.y, radius, 0, 2 * Math.PI);
    } else if (synonyms.includes(word)) {  
        // Rysuj punkt po lewej stronie prostokąta synonimu
        ctx.arc(getWordLeftEdge(word), word.y, radius, 0, 2 * Math.PI);
    }

    ctx.fillStyle = "#FFF"; 
    ctx.fill();
    ctx.strokeStyle = "#000"; // Kolor obramowania
    ctx.stroke();
}

function drawCross(x, y, size = 10) {
    // Rysowanie białego kółka wokół krzyżyka
    const circleRadius = size * 0.75;
    ctx.beginPath();
    ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
    ctx.fillStyle = "#FFF";  // Białe kółko
    ctx.fill();
    ctx.strokeStyle = "#000";  // Czarny obrys kółka
    ctx.lineWidth = 1;
    ctx.stroke();

    // Rysowanie krzyżyka
    ctx.beginPath();
    ctx.moveTo(x - size / 2, y - size / 2);
    ctx.lineTo(x + size / 2, y + size / 2);
    ctx.moveTo(x + size / 2, y - size / 2);
    ctx.lineTo(x - size / 2, y + size / 2);
    ctx.strokeStyle = "#FF0000";  // Czerwony krzyżyk
    ctx.lineWidth = 2;
    ctx.stroke();
}

function getWordAtPosition(x, y, wordList) {
    return wordList.find(word => {
        const rectX = word.x - word.rectWidth / 2;
        const rectY = word.y - word.rectHeight / 2;

        return x >= rectX && x <= rectX + word.rectWidth && y >= rectY && y <= rectY + word.rectHeight;
    });
}

function getConnectionPointAtPosition(x, y) {
    const radius = 5;
    return [...words, ...synonyms].find(word => {
        let pointX, pointY;
        if (words.includes(word)) {
            pointX = getWordRightEdge(word);
            pointY = word.y;
        } else if (synonyms.includes(word)) {
            pointX = getWordLeftEdge(word);
            pointY = word.y;
        }
        const dx = x - pointX;
        const dy = y - pointY;
        return Math.sqrt(dx * dx + dy * dy) < radius;
    });
}

function isClickOnCross(x, y, connection) {
    // Pobierz pozycje
    const wordRightEdge = getWordRightEdge(connection.word);
    const synonymLeftEdge = getWordLeftEdge(connection.synonym);

    const midX = (wordRightEdge + synonymLeftEdge) / 2;
    const midY = (connection.word.y + connection.synonym.y) / 2;

    const dx = x - midX;
    const dy = y - midY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Zwracamy true, jeśli kliknięto blisko krzyżyka (np. w promieniu 15px)
    return distance < 15;
}

function makeConnection(word, synonym) {
    // Usuwamy istniejące połączenia, które dotyczą tego słowa lub synonimu
    connections = connections.filter(connection => connection.word !== word && connection.synonym !== synonym);

    const correct = word.id === synonym.id;  // Sprawdzamy, czy połączenie jest prawidłowe

    connections.push({
        word: word,
        synonym: synonym,
        correct: correct
    });
}

canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    // Najpierw sprawdź, czy kliknięto na krzyżyk, aby usunąć połączenie
    const clickedConnection = connections.find(connection => isClickOnCross(mouseX, mouseY, connection));

    if (clickedConnection) {
        connections = connections.filter(connection => connection !== clickedConnection);
        drawWords();
    } else {
        // W przeciwnym razie sprawdź, czy kliknięto na słowo lub synonim
        const clickedWord = getWordAtPosition(mouseX, mouseY, words);
        const clickedSynonym = getWordAtPosition(mouseX, mouseY, synonyms);

        if (clickedWord) {
            currentWord = clickedWord;
            draggingLine = true;
        } 
        else if (clickedSynonym) {
            currentWord = clickedSynonym;
            draggingLine = true;
        }
    }
});

canvas.addEventListener("mousemove", (e) => {
    if (draggingLine && currentWord) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        drawWords();  

        ctx.beginPath();

        if (words.includes(currentWord)) {
            ctx.moveTo(getWordRightEdge(currentWord), currentWord.y);
        } else {
            ctx.moveTo(getWordLeftEdge(currentWord), currentWord.y);
        }

        ctx.lineTo(mouseX, mouseY);

        ctx.strokeStyle = "#000";  
        ctx.lineWidth = 2; 
        ctx.stroke();
    }
});

canvas.addEventListener("mouseup", (e) => {
    if (draggingLine && currentWord) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        const target = getConnectionPointAtPosition(mouseX, mouseY);

        if (target && target !== currentWord) {
            if (words.includes(currentWord) && synonyms.includes(target)) {
                makeConnection(currentWord, target);
            } else if (synonyms.includes(currentWord) && words.includes(target)) {
                makeConnection(target, currentWord);
            }
        }

        draggingLine = false;
        currentWord = null;
        drawWords();  // Przerysuj wszystkie elementy
    }
});

// Dodaj nasłuchiwanie zdarzenia kliknięcia, aby obsłużyć usuwanie połączeń przez kliknięcie na krzyżyk
canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    const clickedConnection = connections.find(connection => isClickOnCross(mouseX, mouseY, connection));

    if (clickedConnection) {
        connections = connections.filter(connection => connection !== clickedConnection);
        drawWords();
    }
});
</script>
{% endblock %}
